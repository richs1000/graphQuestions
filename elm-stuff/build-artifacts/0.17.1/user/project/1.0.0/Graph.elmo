var _user$project$Graph$randomEdge = function (model) {
	var graph = model.graph;
	var edges = graph.edges;
	var index = _elm_lang$core$List$head(
		A2(
			_elm_lang$core$List$filter,
			function (n) {
				return _elm_lang$core$Native_Utils.cmp(
					n,
					_elm_lang$core$List$length(edges)) < 0;
			},
			model.randomValues));
	var i = A2(
		_elm_lang$core$Maybe$withDefault,
		_elm_lang$core$List$length(edges) - 1,
		index);
	var edge = _elm_lang$core$List$head(
		A2(_elm_lang$core$List$drop, i, edges));
	var _p0 = edge;
	if (_p0.ctor === 'Nothing') {
		return _user$project$Types$emptyEdge;
	} else {
		return _p0._0;
	}
};
var _user$project$Graph$randomNode = F2(
	function (model, alreadyChosen) {
		var graph = model.graph;
		var validNodes = A2(
			_elm_lang$core$List$filter,
			function (n) {
				return _elm_lang$core$Basics$not(
					A2(_elm_lang$core$List$member, n, alreadyChosen));
			},
			A2(
				_elm_lang$core$List$filter,
				function (n) {
					return A2(_elm_lang$core$List$member, n, graph.nodes);
				},
				model.randomValues));
		var rNode = _elm_lang$core$List$head(validNodes);
		var _p1 = rNode;
		if (_p1.ctor === 'Nothing') {
			return 0;
		} else {
			return _p1._0;
		}
	});
var _user$project$Graph$mergeDuplicates = function (edges) {
	var _p2 = edges;
	if (_p2.ctor === '[]') {
		return _elm_lang$core$Native_List.fromArray(
			[]);
	} else {
		var _p5 = _p2._0;
		var _p3 = A2(
			_elm_lang$core$List$partition,
			function (ee) {
				return _elm_lang$core$Native_Utils.eq(_p5.to, ee.from) && _elm_lang$core$Native_Utils.eq(_p5.from, ee.to);
			},
			_p2._1);
		var rev = _p3._0;
		var notRev = _p3._1;
		var _p4 = rev;
		if (_p4.ctor === '[]') {
			return A2(
				_elm_lang$core$List_ops['::'],
				_p5,
				_user$project$Graph$mergeDuplicates(notRev));
		} else {
			return A2(
				_elm_lang$core$List_ops['::'],
				_elm_lang$core$Native_Utils.update(
					_p5,
					{direction: _user$project$Types$BiDirectional}),
				_user$project$Graph$mergeDuplicates(notRev));
		}
	}
};
var _user$project$Graph$lastNode = function (model) {
	var _p6 = model.graph;
	var nodes = _p6.nodes;
	var edges = _p6.edges;
	var directed = _p6.directed;
	var weighted = _p6.weighted;
	var nodes$ = _elm_lang$core$List$reverse(nodes);
	var _p7 = nodes$;
	if (_p7.ctor === '[]') {
		return 0;
	} else {
		return _p7._0;
	}
};
var _user$project$Graph$firstNode = function (model) {
	var _p8 = model.graph;
	var nodes = _p8.nodes;
	var edges = _p8.edges;
	var directed = _p8.directed;
	var weighted = _p8.weighted;
	var _p9 = nodes;
	if (_p9.ctor === '[]') {
		return 0;
	} else {
		return _p9._0;
	}
};
var _user$project$Graph$numberOfEdges = function (model) {
	var _p10 = model.graph;
	var nodes = _p10.nodes;
	var edges = _p10.edges;
	var directed = _p10.directed;
	var weighted = _p10.weighted;
	return _elm_lang$core$List$length(edges);
};
var _user$project$Graph$numberOfNodes = function (model) {
	var _p11 = model.graph;
	var nodes = _p11.nodes;
	var edges = _p11.edges;
	var directed = _p11.directed;
	var weighted = _p11.weighted;
	return _elm_lang$core$List$length(nodes);
};
var _user$project$Graph$outDegree = F2(
	function (graph, node) {
		return _elm_lang$core$List$length(
			A2(
				_elm_lang$core$List$filter,
				function (e) {
					return _elm_lang$core$Native_Utils.eq(e.from, node) || (_elm_lang$core$Native_Utils.eq(e.to, node) && _elm_lang$core$Native_Utils.eq(e.direction, _user$project$Types$BiDirectional));
				},
				graph.edges));
	});
var _user$project$Graph$inDegree = F2(
	function (graph, node) {
		return _elm_lang$core$List$length(
			A2(
				_elm_lang$core$List$filter,
				function (e) {
					return _elm_lang$core$Native_Utils.eq(e.to, node) || (_elm_lang$core$Native_Utils.eq(e.from, node) && _elm_lang$core$Native_Utils.eq(e.direction, _user$project$Types$BiDirectional));
				},
				graph.edges));
	});
var _user$project$Graph$degree = F2(
	function (graph, node) {
		return _elm_lang$core$List$length(
			A2(
				_elm_lang$core$List$filter,
				function (e) {
					return _elm_lang$core$Native_Utils.eq(e.from, node) || _elm_lang$core$Native_Utils.eq(e.to, node);
				},
				graph.edges));
	});
var _user$project$Graph$edgeExists = F3(
	function (graph, n1, n2) {
		var n2_to_n1_non = _elm_lang$core$Basics$not(graph.directed) && A2(
			_elm_lang$core$List$any,
			function (e) {
				return _elm_lang$core$Native_Utils.eq(e.from, n2) && _elm_lang$core$Native_Utils.eq(e.to, n1);
			},
			graph.edges);
		var n2_to_n1_bi = A2(
			_elm_lang$core$List$any,
			function (e) {
				return _elm_lang$core$Native_Utils.eq(e.from, n2) && (_elm_lang$core$Native_Utils.eq(e.to, n1) && _elm_lang$core$Native_Utils.eq(e.direction, _user$project$Types$BiDirectional));
			},
			graph.edges);
		var n1_to_n2 = A2(
			_elm_lang$core$List$any,
			function (e) {
				return _elm_lang$core$Native_Utils.eq(e.from, n1) && _elm_lang$core$Native_Utils.eq(e.to, n2);
			},
			graph.edges);
		return n1_to_n2 || (n2_to_n1_bi || n2_to_n1_non);
	});
var _user$project$Graph$visited = F3(
	function (openList, closedList, node) {
		return A2(_elm_lang$core$List$member, node, openList) || A2(_elm_lang$core$List$member, node, closedList);
	});
var _user$project$Graph$updateGraph = F5(
	function (model, ns, es, d, w) {
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				graph: {nodes: ns, edges: es, directed: d, weighted: w}
			});
	});
var _user$project$Graph$stripList = function (maybes) {
	stripList:
	while (true) {
		var _p12 = maybes;
		if (_p12.ctor === '[]') {
			return _elm_lang$core$Native_List.fromArray(
				[]);
		} else {
			if (_p12._0.ctor === 'Just') {
				return A2(
					_elm_lang$core$List_ops['::'],
					_p12._0._0,
					_user$project$Graph$stripList(_p12._1));
			} else {
				var _v7 = _p12._1;
				maybes = _v7;
				continue stripList;
			}
		}
	}
};
var _user$project$Graph$createEdgesFromNode = F2(
	function (fromNode, neighbors) {
		var _p13 = neighbors;
		if (_p13.ctor === '[]') {
			return _elm_lang$core$Native_List.fromArray(
				[]);
		} else {
			return A2(
				_elm_lang$core$List_ops['::'],
				A4(_user$project$Types$Edge, fromNode, _p13._0, 0, _user$project$Types$UniDirectional),
				A2(_user$project$Graph$createEdgesFromNode, fromNode, _p13._1));
		}
	});
var _user$project$Graph$nodesPerCol = 4;
var _user$project$Graph$nodeRow = function (node) {
	return (node / _user$project$Graph$nodesPerCol) | 0;
};
var _user$project$Graph$sameRow = F2(
	function (n1, n2) {
		return _elm_lang$core$Native_Utils.eq((n1 / _user$project$Graph$nodesPerCol) | 0, (n2 / _user$project$Graph$nodesPerCol) | 0);
	});
var _user$project$Graph$nodeCol = function (node) {
	return A2(_elm_lang$core$Basics$rem, node, _user$project$Graph$nodesPerCol);
};
var _user$project$Graph$sameCol = F2(
	function (n1, n2) {
		return _elm_lang$core$Native_Utils.eq(
			A2(_elm_lang$core$Basics$rem, n1, _user$project$Graph$nodesPerCol),
			A2(_elm_lang$core$Basics$rem, n1, _user$project$Graph$nodesPerCol));
	});
var _user$project$Graph$edgesOverlap = F2(
	function (e1, e2) {
		return A2(_user$project$Graph$sameRow, e1.from, e1.to) && (A2(_user$project$Graph$sameCol, e2.from, e2.to) && ((((_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeRow(e2.from),
			_user$project$Graph$nodeRow(e1.from)) < 0) && (_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeRow(e1.from),
			_user$project$Graph$nodeRow(e2.to)) < 0)) || ((_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeRow(e2.to),
			_user$project$Graph$nodeRow(e1.from)) < 0) && (_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeRow(e1.from),
			_user$project$Graph$nodeRow(e2.from)) < 0))) && (((_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeCol(e1.from),
			_user$project$Graph$nodeCol(e2.from)) < 0) && (_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeCol(e2.from),
			_user$project$Graph$nodeCol(e1.to)) < 0)) || ((_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeCol(e1.to),
			_user$project$Graph$nodeCol(e2.from)) < 0) && (_elm_lang$core$Native_Utils.cmp(
			_user$project$Graph$nodeCol(e2.from),
			_user$project$Graph$nodeCol(e1.from)) < 0)))));
	});
var _user$project$Graph$removeOverlappingEdges = function (edges) {
	var _p14 = edges;
	if (_p14.ctor === '[]') {
		return _elm_lang$core$Native_List.fromArray(
			[]);
	} else {
		var _p16 = _p14._0;
		var _p15 = A2(
			_elm_lang$core$List$partition,
			function (ee) {
				return A2(_user$project$Graph$edgesOverlap, _p16, ee) || A2(_user$project$Graph$edgesOverlap, ee, _p16);
			},
			_p14._1);
		var overlap = _p15._0;
		var notOverlap = _p15._1;
		return A2(
			_elm_lang$core$List_ops['::'],
			_p16,
			_user$project$Graph$removeOverlappingEdges(notOverlap));
	}
};
var _user$project$Graph$replaceWeights = F2(
	function (edges, newWeights) {
		return _user$project$Graph$removeOverlappingEdges(
			_user$project$Graph$mergeDuplicates(
				A2(
					_elm_lang$core$List$filter,
					function (e) {
						return _elm_lang$core$Native_Utils.cmp(e.weight, 0) > 0;
					},
					A3(
						_elm_lang$core$List$map2,
						F2(
							function (e, w) {
								return {from: e.from, to: e.to, weight: w, direction: e.direction};
							}),
						edges,
						newWeights))));
	});
var _user$project$Graph$nodesPerRow = 4;
var _user$project$Graph$closestNeighbor = F4(
	function (allNodes, fromNode, pred, offset) {
		var closestNeighborHelper = function (nodeId) {
			closestNeighborHelper:
			while (true) {
				if ((_elm_lang$core$Native_Utils.cmp(nodeId, 0) < 0) || (_elm_lang$core$Native_Utils.cmp(nodeId, _user$project$Graph$nodesPerRow * _user$project$Graph$nodesPerCol) > -1)) {
					return _elm_lang$core$Maybe$Nothing;
				} else {
					if (A2(_elm_lang$core$List$member, nodeId, allNodes) && A2(pred, fromNode, nodeId)) {
						return _elm_lang$core$Maybe$Just(nodeId);
					} else {
						var _v10 = nodeId + offset;
						nodeId = _v10;
						continue closestNeighborHelper;
					}
				}
			}
		};
		return closestNeighborHelper(fromNode + offset);
	});
var _user$project$Graph$findNeighbors = F2(
	function (nodes, node) {
		return _elm_lang$core$Native_List.fromArray(
			[
				A4(_user$project$Graph$closestNeighbor, nodes, node, _user$project$Graph$sameRow, 1),
				A4(_user$project$Graph$closestNeighbor, nodes, node, _user$project$Graph$sameRow, -1),
				A4(_user$project$Graph$closestNeighbor, nodes, node, _user$project$Graph$sameCol, _user$project$Graph$nodesPerRow),
				A4(_user$project$Graph$closestNeighbor, nodes, node, _user$project$Graph$sameCol, 0 - _user$project$Graph$nodesPerRow)
			]);
	});
var _user$project$Graph$createAllEdges = function (nodes) {
	var createAllEdgesHelper = F2(
		function (allNodes, nodes) {
			var _p17 = nodes;
			if (_p17.ctor === '[]') {
				return _elm_lang$core$Native_List.fromArray(
					[]);
			} else {
				var _p18 = _p17._0;
				return A2(
					_elm_lang$core$List$append,
					A2(
						_user$project$Graph$createEdgesFromNode,
						_p18,
						_user$project$Graph$stripList(
							A2(_user$project$Graph$findNeighbors, allNodes, _p18))),
					A2(createAllEdgesHelper, allNodes, _p17._1));
			}
		});
	return A2(createAllEdgesHelper, nodes, nodes);
};
